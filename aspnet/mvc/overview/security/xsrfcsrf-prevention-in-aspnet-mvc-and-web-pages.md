---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Prévention de XSRF/CSRF dans ASP.NET MVC et les pages Web | Microsoft Docs
author: Rick-Anderson
description: La falsification de requête intersites (également appelée XSRF ou CSRF) est une attaque contre les applications hébergées sur le Web, ce qui permet à un site Web malveillant d’influencer l’interaction...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455527"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="b4d80-103">Prévention de XSRF/CSRF dans ASP.NET MVC et les pages web</span><span class="sxs-lookup"><span data-stu-id="b4d80-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="b4d80-104">par [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="b4d80-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="b4d80-105">La falsification de requête intersites (également appelée XSRF ou CSRF) est une attaque contre les applications hébergées sur le Web, ce qui permet à un site Web malveillant d’influencer l’interaction entre un navigateur client et un site Web approuvé par ce navigateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="b4d80-106">Ces attaques sont rendues possibles, car les navigateurs Web enverront automatiquement des jetons d’authentification à chaque demande adressée à un site Web.</span><span class="sxs-lookup"><span data-stu-id="b4d80-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="b4d80-107">L'exemple classique est le cookie d'authentification, comme le ticket d'authentification d'ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="b4d80-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="b4d80-108">Toutefois, les sites Web qui utilisent un mécanisme d’authentification persistant (tel que l’authentification Windows, de base, etc.) peuvent être ciblés par ces attaques.</span><span class="sxs-lookup"><span data-stu-id="b4d80-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="b4d80-109">Une attaque XSRF est différente d'une attaque par hameçonnage (ou « phishing »).</span><span class="sxs-lookup"><span data-stu-id="b4d80-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="b4d80-110">Les attaques par hameçonnage requièrent une interaction avec la victime.</span><span class="sxs-lookup"><span data-stu-id="b4d80-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="b4d80-111">Dans une attaque par hameçonnage, un site Web malveillant imite le site Web cible et la victime est trompeur en fournissant des informations sensibles à la personne malveillante.</span><span class="sxs-lookup"><span data-stu-id="b4d80-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="b4d80-112">Dans une attaque XSRF, il n'y a généralement pas d'interaction avec la victime.</span><span class="sxs-lookup"><span data-stu-id="b4d80-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="b4d80-113">Au lieu de cela, le pirate s’appuie sur le navigateur pour envoyer automatiquement tous les cookies pertinents au site Web de destination.</span><span class="sxs-lookup"><span data-stu-id="b4d80-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="b4d80-114">Pour plus d’informations, consultez le projet OWASP ( [Open Web Application Security](https://www.owasp.org/index.php/Main_Page)) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="b4d80-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="b4d80-115">Anatomie d’une attaque</span><span class="sxs-lookup"><span data-stu-id="b4d80-115">Anatomy of an attack</span></span>

<span data-ttu-id="b4d80-116">Pour parcourir une attaque XSRF, envisagez un utilisateur qui souhaite effectuer des transactions bancaires en ligne.</span><span class="sxs-lookup"><span data-stu-id="b4d80-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="b4d80-117">Cet utilisateur accède pour la première fois à WoodgroveBank.com et se connecte, à partir duquel l’en-tête de réponse contiendra son cookie d’authentification :</span><span class="sxs-lookup"><span data-stu-id="b4d80-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="b4d80-118">Étant donné que le cookie d’authentification est un cookie de session, il est automatiquement supprimé par le navigateur lorsque le processus de navigation s’arrête.</span><span class="sxs-lookup"><span data-stu-id="b4d80-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="b4d80-119">Toutefois, jusqu’à ce moment-là, le navigateur inclura automatiquement le cookie avec chaque demande à WoodgroveBank.com.</span><span class="sxs-lookup"><span data-stu-id="b4d80-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="b4d80-120">L’utilisateur souhaite maintenant transférer $1000 vers un autre compte. il remplit donc un formulaire sur le site bancaire et le navigateur envoie cette demande au serveur :</span><span class="sxs-lookup"><span data-stu-id="b4d80-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="b4d80-121">Étant donné que cette opération a un effet secondaire (elle initie une transaction monétaire), le site bancaire a choisi d’exiger un HTTP postal afin de lancer cette opération.</span><span class="sxs-lookup"><span data-stu-id="b4d80-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="b4d80-122">Le serveur lit le jeton d’authentification à partir de la demande, recherche le numéro de compte de l’utilisateur actuel, vérifie qu’il y a suffisamment de fonds, puis initialise la transaction dans le compte de destination.</span><span class="sxs-lookup"><span data-stu-id="b4d80-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="b4d80-123">La Banque en ligne est terminée, l’utilisateur quitte le site bancaire et consulte d’autres sites sur le Web.</span><span class="sxs-lookup"><span data-stu-id="b4d80-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="b4d80-124">L’un de ces sites (fabrikam.com) comprend le balisage suivant sur une page incorporée dans un &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="b4d80-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="b4d80-125">Ce qui amène ensuite le navigateur à effectuer cette requête :</span><span class="sxs-lookup"><span data-stu-id="b4d80-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="b4d80-126">L’attaquant exploite le fait que l’utilisateur peut toujours disposer d’un jeton d’authentification valide pour le site Web cible et qu’il utilise un petit extrait de code JavaScript pour faire en sorte que le navigateur effectue automatiquement une publication HTTP sur le site cible.</span><span class="sxs-lookup"><span data-stu-id="b4d80-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="b4d80-127">Si le jeton d’authentification est toujours valide, le site bancaire initie un transfert de $250 vers le compte du choix de l’attaquant.</span><span class="sxs-lookup"><span data-stu-id="b4d80-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="b4d80-128">Atténuations inefficaces</span><span class="sxs-lookup"><span data-stu-id="b4d80-128">Ineffective mitigations</span></span>

<span data-ttu-id="b4d80-129">Il est intéressant de noter que dans le scénario ci-dessus, le fait que WoodgroveBank.com était accessible via SSL et avait un cookie d’authentification SSL uniquement insuffisant pour contrecarrer l’attaque.</span><span class="sxs-lookup"><span data-stu-id="b4d80-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="b4d80-130">L’attaquant est en mesure de spécifier le [schéma d’URI](http://en.wikipedia.org/wiki/URI_scheme) (https) dans son &lt;&gt; formulaire, et le navigateur continue à envoyer des cookies non expirés au site cible tant que ces cookies sont cohérents avec le schéma d’URI de la cible prévue.</span><span class="sxs-lookup"><span data-stu-id="b4d80-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="b4d80-131">Il est possible de faire en sorte que l’utilisateur ne puisse pas visiter les sites non approuvés, car la visite de sites de confiance uniquement permet de rester en ligne en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="b4d80-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="b4d80-132">Il y a de la vérité, mais malheureusement ce Conseil n’est pas toujours pratique.</span><span class="sxs-lookup"><span data-stu-id="b4d80-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="b4d80-133">Peut-être que l’utilisateur « approuve » le site de News local ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="b4d80-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="b4d80-134">ConsolidatedMessenger.com et accède à ce site à la place, mais ce site présente une vulnérabilité XSS qui permet à une personne malveillante d’injecter le même extrait de code qui s’exécutait sur fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="b4d80-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="b4d80-135">Vous pouvez vérifier que les demandes entrantes comportent un [en-tête Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) référençant votre domaine.</span><span class="sxs-lookup"><span data-stu-id="b4d80-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="b4d80-136">Cela permet d’arrêter les demandes involontairement envoyées à partir d’un domaine tiers.</span><span class="sxs-lookup"><span data-stu-id="b4d80-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="b4d80-137">Toutefois, certaines personnes désactivent l’en-tête Referer de leur navigateur pour des raisons de confidentialité, et les attaquants peuvent parfois usurper cet en-tête si certains logiciels non sécurisés sont installés sur la victime.</span><span class="sxs-lookup"><span data-stu-id="b4d80-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="b4d80-138">La vérification de l' [en-tête Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) n’est pas considérée comme une approche sécurisée pour empêcher les attaques XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="b4d80-139">Atténuations du XSRF d’exécution de la pile Web</span><span class="sxs-lookup"><span data-stu-id="b4d80-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="b4d80-140">Le runtime ASP.NET Web Stack utilise une variante du [modèle de jeton du synchronisateur](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) pour se défendre contre les attaques XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="b4d80-141">La forme générale du modèle de jeton du synchronisateur est que deux jetons anti-XSRF sont envoyés au serveur avec chaque HTTP postérieur (en plus du jeton d’authentification) : un jeton en tant que cookie et l’autre en tant que valeur de formulaire.</span><span class="sxs-lookup"><span data-stu-id="b4d80-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="b4d80-142">Les valeurs de jeton générées par le runtime ASP.NET ne sont pas déterministes ou prévisibles par une personne malveillante.</span><span class="sxs-lookup"><span data-stu-id="b4d80-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="b4d80-143">Lors de l’envoi des jetons, le serveur autorise la requête à continuer uniquement si les deux jetons passent un contrôle de comparaison.</span><span class="sxs-lookup"><span data-stu-id="b4d80-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="b4d80-144">Le *jeton de session* de vérification de demande XSRF est stocké en tant que cookie HTTP et contient actuellement les informations suivantes dans sa charge utile :</span><span class="sxs-lookup"><span data-stu-id="b4d80-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="b4d80-145">Un jeton de sécurité, qui se compose d’un identificateur 128 bits aléatoire.</span><span class="sxs-lookup"><span data-stu-id="b4d80-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="b4d80-146">L’illustration suivante montre le jeton de session de vérification de demande XSRF affiché avec les outils de développement F12 d’Internet Explorer : (Notez qu’il s’agit de l’implémentation actuelle et qu’elle est sujette à modification.)</span><span class="sxs-lookup"><span data-stu-id="b4d80-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="b4d80-147">Le *jeton de champ* est stocké en tant que `<input type="hidden" />` et contient les informations suivantes dans sa charge utile :</span><span class="sxs-lookup"><span data-stu-id="b4d80-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="b4d80-148">Nom d’utilisateur de l’utilisateur connecté (s’il est authentifié).</span><span class="sxs-lookup"><span data-stu-id="b4d80-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="b4d80-149">Toutes les données supplémentaires fournies par un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="b4d80-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="b4d80-150">Les charges utiles des jetons anti-XSRF sont chiffrées et signées. vous ne pouvez donc pas afficher le nom d’utilisateur lorsque vous utilisez des outils pour examiner les jetons.</span><span class="sxs-lookup"><span data-stu-id="b4d80-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="b4d80-151">Lorsque l’application Web cible ASP.NET 4,0, les services de chiffrement sont fournis par la routine [machineKey. Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) .</span><span class="sxs-lookup"><span data-stu-id="b4d80-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="b4d80-152">Lorsque l’application Web cible ASP.NET 4,5 ou une version ultérieure, les services de chiffrement sont fournis par la routine [machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) , qui offre de meilleures performances, une meilleure extensibilité et une plus grande sécurité.</span><span class="sxs-lookup"><span data-stu-id="b4d80-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="b4d80-153">Pour plus d’informations, consultez les billets de blog suivants :</span><span class="sxs-lookup"><span data-stu-id="b4d80-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="b4d80-154">Améliorations du chiffrement dans ASP.NET 4,5, PT. 1</span><span class="sxs-lookup"><span data-stu-id="b4d80-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="b4d80-155">Améliorations du chiffrement dans ASP.NET 4,5, PT. 2</span><span class="sxs-lookup"><span data-stu-id="b4d80-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="b4d80-156">Améliorations du chiffrement dans ASP.NET 4,5, PT. 3</span><span class="sxs-lookup"><span data-stu-id="b4d80-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="b4d80-157">Génération des jetons</span><span class="sxs-lookup"><span data-stu-id="b4d80-157">Generating the tokens</span></span>

<span data-ttu-id="b4d80-158">Pour générer les jetons anti-XSRF, appelez la méthode [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) à partir d’une vue MVC ou @AntiForgery.GetHtml() à partir d’une page Razor.</span><span class="sxs-lookup"><span data-stu-id="b4d80-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="b4d80-159">Le Runtime effectue ensuite les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4d80-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="b4d80-160">Si la requête HTTP actuelle contient déjà un jeton de session anti-XSRF (le cookie anti-XSRF \_\_RequestVerificationToken), le jeton de sécurité est extrait de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="b4d80-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="b4d80-161">Si la requête HTTP ne contient pas de jeton de session anti-XSRF ou si l’extraction du jeton de sécurité échoue, un nouveau jeton anti-XSRF aléatoire est généré.</span><span class="sxs-lookup"><span data-stu-id="b4d80-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="b4d80-162">Un jeton de champ anti-XSRF est généré à l’aide du jeton de sécurité de l’étape (1) ci-dessus et de l’identité de l’utilisateur actuellement connecté.</span><span class="sxs-lookup"><span data-stu-id="b4d80-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="b4d80-163">(Pour plus d’informations sur la détermination de l’identité de l’utilisateur, consultez la section **[scénarios avec prise en charge spéciale](#_Scenarios_with_special)** ci-dessous.) En outre, si un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) est configuré, le runtime appelle sa méthode [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) et inclut la chaîne retournée dans le jeton de champ.</span><span class="sxs-lookup"><span data-stu-id="b4d80-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="b4d80-164">(Pour plus d’informations, consultez la section **[configuration et extensibilité](#_Configuration_and_extensibility)** .)</span><span class="sxs-lookup"><span data-stu-id="b4d80-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="b4d80-165">Si un nouveau jeton anti-XSRF a été généré à l’étape (1), un nouveau jeton de session sera créé pour le contenir et sera ajouté à la collection de cookies HTTP sortants.</span><span class="sxs-lookup"><span data-stu-id="b4d80-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="b4d80-166">Le jeton de champ de l’étape (2) sera encapsulé dans un élément `<input type="hidden" />`, et ce balisage HTML sera la valeur de retour de `Html.AntiForgeryToken()` ou `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="b4d80-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="b4d80-167">Validation des jetons</span><span class="sxs-lookup"><span data-stu-id="b4d80-167">Validating the tokens</span></span>

<span data-ttu-id="b4d80-168">Pour valider les jetons anti-XSRF entrants, le développeur comprend un attribut [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) sur son action ou contrôleur MVC, ou elle appelle `@AntiForgery.Validate()` à partir de sa page Razor.</span><span class="sxs-lookup"><span data-stu-id="b4d80-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="b4d80-169">Le Runtime effectue les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4d80-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="b4d80-170">Le jeton de session entrant et le jeton de champ sont lus et le jeton anti-XSRF extrait de chaque.</span><span class="sxs-lookup"><span data-stu-id="b4d80-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="b4d80-171">Les jetons anti-XSRF doivent être identiques par étape (2) dans la routine de génération.</span><span class="sxs-lookup"><span data-stu-id="b4d80-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="b4d80-172">Si l’utilisateur actuel est authentifié, son nom d’utilisateur est comparé au nom d’utilisateur stocké dans le jeton de champ.</span><span class="sxs-lookup"><span data-stu-id="b4d80-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="b4d80-173">Les noms d’utilisateur doivent correspondre.</span><span class="sxs-lookup"><span data-stu-id="b4d80-173">The usernames must match.</span></span>
3. <span data-ttu-id="b4d80-174">Si un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) est configuré, le runtime appelle sa méthode *ValidateAdditionalData* .</span><span class="sxs-lookup"><span data-stu-id="b4d80-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="b4d80-175">La méthode doit retourner la valeur booléenne *true*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="b4d80-176">Si la validation est réussie, la demande est autorisée à se poursuivre.</span><span class="sxs-lookup"><span data-stu-id="b4d80-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="b4d80-177">Si la validation échoue, le Framework lève une *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="b4d80-178">Conditions d’échec</span><span class="sxs-lookup"><span data-stu-id="b4d80-178">Failure conditions</span></span>

<span data-ttu-id="b4d80-179">À compter du runtime ASP.NET Web Stack v2, les *HttpAntiForgeryException* qui sont levées pendant la validation contiennent des informations détaillées sur ce qui s’est produit.</span><span class="sxs-lookup"><span data-stu-id="b4d80-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="b4d80-180">Les conditions d’échec actuellement définies sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4d80-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="b4d80-181">Le jeton de session ou le jeton de formulaire n’est pas présent dans la demande.</span><span class="sxs-lookup"><span data-stu-id="b4d80-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="b4d80-182">Le jeton de session ou le jeton de formulaire est illisible.</span><span class="sxs-lookup"><span data-stu-id="b4d80-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="b4d80-183">La cause la plus probable est qu’une batterie de serveurs exécutant des versions incompatibles du runtime ASP.NET Web Stack ou d’une batterie de serveurs dans laquelle l’élément &lt;machineKey&gt; dans Web. config diffère entre les ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="b4d80-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="b4d80-184">Vous pouvez utiliser un outil tel que Fiddler pour forcer cette exception en falsifiant un jeton anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="b4d80-185">Le jeton de session et le jeton de champ ont été permutés.</span><span class="sxs-lookup"><span data-stu-id="b4d80-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="b4d80-186">Le jeton de session et le jeton de champ contiennent des jetons de sécurité incompatibles.</span><span class="sxs-lookup"><span data-stu-id="b4d80-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="b4d80-187">Le nom d’utilisateur incorporé dans le jeton de champ ne correspond pas au nom d’utilisateur de l’utilisateur connecté actuel.</span><span class="sxs-lookup"><span data-stu-id="b4d80-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="b4d80-188">La méthode *[IAntiForgeryAdditionalDataProvider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* a retourné la *valeur false*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="b4d80-189">Les fonctionnalités anti-XSRF peuvent également effectuer des vérifications supplémentaires lors de la génération ou de la validation des jetons, et les défaillances pendant ces vérifications peuvent entraîner la levée d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="b4d80-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="b4d80-190">Pour plus d’informations, consultez les sections relative à l’authentification et à la **[configuration et](#_Configuration_and_extensibility)** [l’authentification basée sur WIF/ACS/claims](#_WIF_ACS) .</span><span class="sxs-lookup"><span data-stu-id="b4d80-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="b4d80-191">Scénarios avec prise en charge spéciale</span><span class="sxs-lookup"><span data-stu-id="b4d80-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="b4d80-192">Authentification anonyme</span><span class="sxs-lookup"><span data-stu-id="b4d80-192">Anonymous authentication</span></span>

<span data-ttu-id="b4d80-193">Le système anti-XSRF contient une prise en charge spéciale des utilisateurs anonymes, où « Anonymous » est défini comme utilisateur où la propriété *IIdentity. IsAuthenticated* retourne la *valeur false*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="b4d80-194">Les scénarios incluent la fourniture d’une protection XSRF à la page de connexion (avant l’authentification de l’utilisateur) et les schémas d’authentification personnalisés, où l’application utilise un mécanisme autre que *IIdentity* pour identifier les utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="b4d80-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="b4d80-195">Pour prendre en charge ces scénarios, rappelez-vous que les jetons de session et de champ sont joints par un jeton de sécurité, qui est un identificateur opaque généré de manière aléatoire 128 bits.</span><span class="sxs-lookup"><span data-stu-id="b4d80-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="b4d80-196">Ce jeton de sécurité est utilisé pour suivre la session d’un utilisateur individuel lorsqu’il navigue sur le site, de sorte qu’il sert efficacement à un identificateur anonyme.</span><span class="sxs-lookup"><span data-stu-id="b4d80-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="b4d80-197">Une chaîne vide est utilisée à la place du nom d’utilisateur pour les routines de génération et de validation décrites ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="b4d80-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="b4d80-198">WIF/ACS/authentification basée sur les revendications</span><span class="sxs-lookup"><span data-stu-id="b4d80-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="b4d80-199">Normalement, les classes *IIdentity* intégrées à l' .NET Framework ont la propriété qui *IIdentity.Name* est suffisante pour identifier de manière unique un utilisateur particulier dans une application particulière.</span><span class="sxs-lookup"><span data-stu-id="b4d80-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="b4d80-200">Par exemple, *FormsIdentity.Name* retourne le nom d’utilisateur stocké dans la base de données d’appartenance (qui est unique pour toutes les applications en fonction de cette base de données), *WindowsIdentity.Name* retourne l’identité qualifiée du domaine de l’utilisateur, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="b4d80-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="b4d80-201">Ces systèmes fournissent non seulement une authentification ; ils *identifient* également les utilisateurs pour une application.</span><span class="sxs-lookup"><span data-stu-id="b4d80-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="b4d80-202">L’authentification basée sur les revendications, en revanche, ne nécessite pas nécessairement l’identification d’un utilisateur particulier.</span><span class="sxs-lookup"><span data-stu-id="b4d80-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="b4d80-203">Au lieu de cela, les types *ClaimsPrincipal* et *ClaimsIdentity* sont associés à un ensemble d’instances de *revendication* , où les revendications individuelles peuvent être « is 18 + years of Age » ou « is administrateur » à autre chose.</span><span class="sxs-lookup"><span data-stu-id="b4d80-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="b4d80-204">Étant donné que l’utilisateur n’a pas nécessairement été identifié, le runtime ne peut pas utiliser la propriété *ClaimsIdentity.Name* comme identificateur unique pour cet utilisateur particulier.</span><span class="sxs-lookup"><span data-stu-id="b4d80-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="b4d80-205">L’équipe a vu des exemples concrets où *ClaimsIdentity.Name* retourne *null*, retourne un nom convivial ou retourne une chaîne qui n’est pas appropriée pour une utilisation en tant qu’identificateur unique pour l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="b4d80-206">La plupart des déploiements qui utilisent l’authentification basée sur les revendications utilisent [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) en particulier.</span><span class="sxs-lookup"><span data-stu-id="b4d80-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="b4d80-207">ACS permet au développeur de configurer des *fournisseurs d’identité* individuels (tels que ADFS, le fournisseur de comptes Microsoft, les fournisseurs OpenID comme Yahoo !, etc.) et les fournisseurs d’identité retournent des *identificateurs de nom*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="b4d80-208">Ces identificateurs de noms peuvent contenir des informations d’identification personnelle (PII) comme une adresse de messagerie, ou peuvent être rendues anonymes comme un identificateur personnel privé (PPID).</span><span class="sxs-lookup"><span data-stu-id="b4d80-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="b4d80-209">Quel que soit le Tuple (fournisseur d’identité, identificateur de nom) suffisamment utilisé comme jeton de suivi approprié pour un utilisateur particulier pendant qu’il parcourt le site, le runtime ASP.NET Web Stack peut utiliser le tuple à la place du nom d’utilisateur lors de la génération et validation des jetons de champ anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="b4d80-210">Les URI particuliers pour le fournisseur d’identité et l’identificateur de nom sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="b4d80-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="b4d80-211">(pour plus d’informations, consultez cette [page de document](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) des services ACS.)</span><span class="sxs-lookup"><span data-stu-id="b4d80-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="b4d80-212">Lors de la génération ou de la validation d’un jeton, le runtime ASP.NET Web Stack effectue une liaison d’essai avec les types :</span><span class="sxs-lookup"><span data-stu-id="b4d80-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="b4d80-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (pour le kit de développement logiciel (SDK) WIF.)</span><span class="sxs-lookup"><span data-stu-id="b4d80-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="b4d80-214">`System.Security.Claims.ClaimsIdentity` (pour .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="b4d80-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="b4d80-215">Si ces types existent, et si le *IIIIdentity* de l’utilisateur actuel implémente ou sous-classe l’un de ces types, la fonction anti-XSRF utilise le Tuple (fournisseur d’identité, identificateur de nom) à la place du nom d’utilisateur lors de la génération et de la validation des jetons.</span><span class="sxs-lookup"><span data-stu-id="b4d80-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="b4d80-216">Si aucun tuple de ce type n’est présent, la requête échoue avec une erreur décrivant au développeur comment configurer le système anti-XSRF pour comprendre le mécanisme d’authentification basé sur les revendications en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="b4d80-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="b4d80-217">Pour plus d’informations, consultez la section **[configuration et extensibilité](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="b4d80-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="b4d80-218">Authentification OAuth/OpenID</span><span class="sxs-lookup"><span data-stu-id="b4d80-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="b4d80-219">Enfin, la fonction anti-XSRF offre une prise en charge spéciale des applications qui utilisent l’authentification OAuth ou OpenID.</span><span class="sxs-lookup"><span data-stu-id="b4d80-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="b4d80-220">Cette prise en charge est basée sur une méthode heuristique : si le *IIdentity.Name* actuel commence par http://ou https://, les comparaisons de noms d’utilisateur seront effectuées à l’aide d’un comparateur ordinal plutôt que du comparateur OrdinalIgnoreCase par défaut.</span><span class="sxs-lookup"><span data-stu-id="b4d80-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="b4d80-221">Configuration et extensibilité</span><span class="sxs-lookup"><span data-stu-id="b4d80-221">Configuration and extensibility</span></span>

<span data-ttu-id="b4d80-222">Parfois, les développeurs peuvent souhaiter un contrôle plus étroit sur les comportements de génération et de validation anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="b4d80-223">Par exemple, il est possible que le comportement par défaut des applications MVC et Web pages d’ajout automatique de cookies HTTP à la réponse ne soit pas souhaitable et que le développeur souhaite conserver les jetons ailleurs.</span><span class="sxs-lookup"><span data-stu-id="b4d80-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="b4d80-224">Il existe deux API pour vous aider :</span><span class="sxs-lookup"><span data-stu-id="b4d80-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="b4d80-225">La méthode *GetTokens* prend comme entrée un jeton de session de vérification de demande XSRF existant (qui peut être null) et produit comme sortie un nouveau jeton de session de vérification de demande XSRF et un jeton de champ.</span><span class="sxs-lookup"><span data-stu-id="b4d80-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="b4d80-226">Les jetons sont simplement des chaînes opaques sans décoration. la valeur *formToken* ne sera pas incluse dans un wrapper dans une balise d’entrée de&gt; &lt;.</span><span class="sxs-lookup"><span data-stu-id="b4d80-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="b4d80-227">La valeur *newCookieToken* peut être null ; Si cela se produit, la valeur *oldCookieToken* est toujours valide et aucun nouveau cookie de réponse n’a besoin d’être défini.</span><span class="sxs-lookup"><span data-stu-id="b4d80-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="b4d80-228">L’appelant de *GetTokens* est responsable de la persistance des cookies de réponse nécessaires ou de la génération de tout balisage nécessaire. la méthode *GetTokens* elle-même ne modifie pas la réponse en tant qu’effet secondaire.</span><span class="sxs-lookup"><span data-stu-id="b4d80-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="b4d80-229">La méthode *Validate* prend les jetons de session et de champ entrants et exécute la logique de validation mentionnée ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="b4d80-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="b4d80-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="b4d80-230">AntiForgeryConfig</span></span>

<span data-ttu-id="b4d80-231">Le développeur peut configurer le système anti-XSRF à partir du démarrage de l’application\_.</span><span class="sxs-lookup"><span data-stu-id="b4d80-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="b4d80-232">La configuration est programmée.</span><span class="sxs-lookup"><span data-stu-id="b4d80-232">Configuration is programmatic.</span></span> <span data-ttu-id="b4d80-233">Les propriétés du type *AntiForgeryConfig* statique sont décrites ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="b4d80-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="b4d80-234">La plupart des utilisateurs qui utilisent des revendications doivent définir la propriété UniqueClaimTypeIdentifier.</span><span class="sxs-lookup"><span data-stu-id="b4d80-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="b4d80-235">**Propriété**</span><span class="sxs-lookup"><span data-stu-id="b4d80-235">**Property**</span></span> | <span data-ttu-id="b4d80-236">**Description**</span><span class="sxs-lookup"><span data-stu-id="b4d80-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="b4d80-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="b4d80-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="b4d80-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) qui fournit des données supplémentaires lors de la génération du jeton et qui consomme des données supplémentaires lors de la validation du jeton.</span><span class="sxs-lookup"><span data-stu-id="b4d80-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="b4d80-239">La valeur par défaut est *null*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-239">The default value is *null*.</span></span> <span data-ttu-id="b4d80-240">Pour plus d’informations, consultez la section [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="b4d80-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="b4d80-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="b4d80-241">**CookieName**</span></span> | <span data-ttu-id="b4d80-242">Chaîne qui fournit le nom du cookie HTTP utilisé pour stocker le jeton de session anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="b4d80-243">Si cette valeur n’est pas définie, un nom est généré automatiquement en fonction du chemin d’accès virtuel déployé de l’application.</span><span class="sxs-lookup"><span data-stu-id="b4d80-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="b4d80-244">La valeur par défaut est *null*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-244">The default value is *null*.</span></span> |
| <span data-ttu-id="b4d80-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="b4d80-245">**RequireSsl**</span></span> | <span data-ttu-id="b4d80-246">Valeur booléenne qui détermine si les jetons anti-XSRF doivent être soumis sur un canal sécurisé SSL.</span><span class="sxs-lookup"><span data-stu-id="b4d80-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="b4d80-247">Si cette valeur est *true*, tous les cookies générés automatiquement ont l’indicateur « Secure » défini, et les API anti-XSRF lèvent si elles sont appelées à partir d’une demande qui n’est pas envoyée via SSL.</span><span class="sxs-lookup"><span data-stu-id="b4d80-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="b4d80-248">La valeur par défaut est *false*.</span><span class="sxs-lookup"><span data-stu-id="b4d80-248">The default value is *false*.</span></span> |
| <span data-ttu-id="b4d80-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="b4d80-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="b4d80-250">Valeur booléenne qui détermine si le système anti-XSRF doit désactiver sa prise en charge des identités basées sur les revendications.</span><span class="sxs-lookup"><span data-stu-id="b4d80-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="b4d80-251">Si cette valeur est *true*, le système suppose que *IIdentity.Name* est approprié pour une utilisation en tant qu’identificateur unique pour chaque utilisateur et ne tente pas d’effectuer une opération spéciale *IClaimsIdentity* ou *ClClaimsIdentity* comme décrit dans la section [WIF/ACS/authentification basée sur les revendications](#_WIF_ACS) .</span><span class="sxs-lookup"><span data-stu-id="b4d80-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="b4d80-252">La valeur par défaut est `false`.</span><span class="sxs-lookup"><span data-stu-id="b4d80-252">The default value is `false`.</span></span> |
| <span data-ttu-id="b4d80-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="b4d80-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="b4d80-254">Chaîne qui indique le type de revendication approprié pour une utilisation en tant qu’identificateur unique pour chaque utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="b4d80-255">Si cette valeur est définie et que le *IIdentity* actuel est basé sur les revendications, le système tente d’extraire une revendication du type spécifié par *UniqueClaimTypeIdentifier*, et la valeur correspondante est utilisée à la place du nom d’utilisateur de l’utilisateur lors de la génération du jeton de champ.</span><span class="sxs-lookup"><span data-stu-id="b4d80-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="b4d80-256">Si le type de revendication est introuvable, le système ne parvient pas à effectuer la requête.</span><span class="sxs-lookup"><span data-stu-id="b4d80-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="b4d80-257">La valeur par défaut est *null*, ce qui indique que le système doit utiliser le Tuple (fournisseur d’identité, identificateur de nom) comme décrit précédemment à la place du nom d’utilisateur de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="b4d80-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="b4d80-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="b4d80-259">Le type *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* permet aux développeurs d’étendre le comportement du système anti-XSRF en arrondissant les données supplémentaires dans chaque jeton.</span><span class="sxs-lookup"><span data-stu-id="b4d80-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="b4d80-260">La méthode *GetAdditionalData* est appelée chaque fois qu’un jeton de champ est généré, et la valeur de retour est incorporée dans le jeton généré.</span><span class="sxs-lookup"><span data-stu-id="b4d80-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="b4d80-261">Un responsable de l’implémentation peut retourner un horodateur, une valeur à usage unique ou toute autre valeur qu’il souhaite de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="b4d80-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="b4d80-262">De même, la méthode *ValidateAdditionalData* est appelée chaque fois qu’un jeton de champ est validé et la chaîne « données supplémentaires » incorporée dans le jeton est transmise à la méthode.</span><span class="sxs-lookup"><span data-stu-id="b4d80-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="b4d80-263">La routine de validation peut implémenter un délai d’expiration (en vérifiant l’heure actuelle par rapport à l’heure de la création du jeton), une routine de vérification de la valeur à usage unique ou toute autre logique souhaitée.</span><span class="sxs-lookup"><span data-stu-id="b4d80-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="b4d80-264">Décisions de conception et considérations relatives à la sécurité</span><span class="sxs-lookup"><span data-stu-id="b4d80-264">Design decisions and security considerations</span></span>

<span data-ttu-id="b4d80-265">Le jeton de sécurité qui lie les jetons de session et de champ est techniquement nécessaire uniquement lorsque vous tentez de protéger des utilisateurs anonymes/non authentifiés contre les attaques XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="b4d80-266">Lorsque l’utilisateur est authentifié, le jeton d’authentification lui-même (soumis de manière présumée sous la forme d’un cookie) peut être utilisé comme moitié d’une paire de jetons de synchronisateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="b4d80-267">Toutefois, il existe des scénarios valides pour la protection des pages de connexion atteintes par des utilisateurs non authentifiés, et la logique anti-XSRF a été simplifiée par la génération et la validation systématiques du jeton de sécurité, même pour les utilisateurs authentifiés.</span><span class="sxs-lookup"><span data-stu-id="b4d80-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="b4d80-268">Elle offre également une protection supplémentaire au cas où un jeton de champ serait compromis par un pirate, car la définition ou la découverte du jeton de session serait un autre obstacle à la surmonter par l’attaquant.</span><span class="sxs-lookup"><span data-stu-id="b4d80-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="b4d80-269">Les développeurs doivent faire attention lorsque plusieurs applications sont hébergées dans un domaine unique.</span><span class="sxs-lookup"><span data-stu-id="b4d80-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="b4d80-270">Par exemple, même si *example1.cloudapp.net* et *example2.cloudapp.net* sont des hôtes différents, il existe une relation d’approbation implicite entre tous les ordinateurs hôtes dans le domaine *\*. cloudapp.net* .</span><span class="sxs-lookup"><span data-stu-id="b4d80-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="b4d80-271">Cette relation d’approbation implicite [permet aux hôtes potentiellement non fiables d’affecter les cookies de l’autre](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (les stratégies de même origine qui régissent les demandes Ajax ne s’appliquent pas nécessairement aux cookies http).</span><span class="sxs-lookup"><span data-stu-id="b4d80-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="b4d80-272">Le runtime ASP.NET Web Stack fournit une certaine atténuation dans le fait que le nom d’utilisateur est incorporé dans le jeton de champ. par conséquent, même si un sous-domaine malveillant est en mesure de remplacer un jeton de session, il ne pourra pas générer un jeton de champ valide pour l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4d80-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="b4d80-273">Toutefois, en cas d’hébergement dans ce type d’environnement, les routines anti-XSRF intégrées ne peuvent toujours pas se défendre contre le détournement de session ou les XSRF de connexion.</span><span class="sxs-lookup"><span data-stu-id="b4d80-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="b4d80-274">Actuellement, les routines anti-XSRF ne se protègent pas contre [le détournement](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="b4d80-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b4d80-275">Les applications qui souhaitent se défendre contre le détournement peuvent facilement le faire en envoyant un en-tête X-Frame-options : SAMEORIGIN avec chaque réponse.</span><span class="sxs-lookup"><span data-stu-id="b4d80-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="b4d80-276">Cet en-tête est pris en charge par tous les navigateurs récents.</span><span class="sxs-lookup"><span data-stu-id="b4d80-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="b4d80-277">Pour plus d’informations, consultez le [blog IE](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), le [blog SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)et [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="b4d80-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b4d80-278">Le runtime ASP.NET Web Stack peut, dans une version ultérieure, faire en sorte que les programmes d’assistance anti-XSRF MVC et Web pages définissent automatiquement cet en-tête afin que les applications soient automatiquement protégées contre cette attaque.</span><span class="sxs-lookup"><span data-stu-id="b4d80-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="b4d80-279">Les développeurs Web doivent continuer à s’assurer que leur site ne soit pas vulnérable aux attaques XSS.</span><span class="sxs-lookup"><span data-stu-id="b4d80-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="b4d80-280">Les attaques XSS sont très puissantes et une exploitation réussie interrompt également les défenses du runtime Web Stack ASP.NET contre les attaques XSRF.</span><span class="sxs-lookup"><span data-stu-id="b4d80-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="b4d80-281">Accusé de réception</span><span class="sxs-lookup"><span data-stu-id="b4d80-281">Acknowledgment</span></span>

<span data-ttu-id="b4d80-282">[@LeviBroderick](https://twitter.com/LeviBroderick), qui a écrit une grande partie du code de sécurité ASP.net, il s’agit de l’essentiel de ces informations.</span><span class="sxs-lookup"><span data-stu-id="b4d80-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
