---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Comprendre et gérer les événements de durée de vie de connexion dans Signalr | Microsoft Docs
author: bradygaster
description: Cet article explique comment utiliser les événements exposés par l’API hubs.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78578812"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="1773f-103">Présentation et gestion des événements de durée de vie des connexions dans SignalR</span><span class="sxs-lookup"><span data-stu-id="1773f-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="1773f-104">Cet article fournit une vue d’ensemble de la connexion Signalr, des événements de reconnexion et de déconnexion que vous pouvez gérer, ainsi que des paramètres de délai d’attente et de conservation que vous pouvez configurer.</span><span class="sxs-lookup"><span data-stu-id="1773f-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="1773f-105">Cet article suppose que vous avez déjà une connaissance des événements Signalr et de la durée de vie de la connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="1773f-106">Pour une présentation de Signalr, consultez [Présentation de signalr](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="1773f-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="1773f-107">Pour obtenir la liste des événements de durée de vie des connexions, consultez les ressources suivantes :</span><span class="sxs-lookup"><span data-stu-id="1773f-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="1773f-108">Comment gérer les événements de durée de vie de connexion dans la classe de concentrateur</span><span class="sxs-lookup"><span data-stu-id="1773f-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="1773f-109">Comment gérer les événements de durée de vie de connexion dans les clients JavaScript</span><span class="sxs-lookup"><span data-stu-id="1773f-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="1773f-110">Comment gérer les événements de durée de vie de connexion dans les clients .NET</span><span class="sxs-lookup"><span data-stu-id="1773f-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="1773f-111">Versions logicielles utilisées dans cette rubrique</span><span class="sxs-lookup"><span data-stu-id="1773f-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="1773f-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="1773f-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="1773f-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="1773f-113">.NET 4.5</span></span>
> - <span data-ttu-id="1773f-114">Signalr version 2</span><span class="sxs-lookup"><span data-stu-id="1773f-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="1773f-115">Versions précédentes de cette rubrique</span><span class="sxs-lookup"><span data-stu-id="1773f-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="1773f-116">Pour plus d’informations sur les versions antérieures de Signalr, consultez [versions antérieures de signalr](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="1773f-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="1773f-117">Questions et commentaires</span><span class="sxs-lookup"><span data-stu-id="1773f-117">Questions and comments</span></span>
>
> <span data-ttu-id="1773f-118">N’hésitez pas à nous faire part de vos commentaires sur la façon dont vous aimez ce didacticiel et sur ce que nous pourrions améliorer dans les commentaires en bas de la page.</span><span class="sxs-lookup"><span data-stu-id="1773f-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="1773f-119">Si vous avez des questions qui ne sont pas directement liées au didacticiel, vous pouvez les poster sur le [forum ASP.net signalr](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) ou [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="1773f-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="1773f-120">Présentation</span><span class="sxs-lookup"><span data-stu-id="1773f-120">Overview</span></span>

<span data-ttu-id="1773f-121">Cet article contient les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="1773f-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="1773f-122">Scénarios et terminologie de la durée de vie de la connexion</span><span class="sxs-lookup"><span data-stu-id="1773f-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="1773f-123">Connexions signalr, connexions de transport et connexions physiques</span><span class="sxs-lookup"><span data-stu-id="1773f-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="1773f-124">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="1773f-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="1773f-125">Scénarios de déconnexion du client</span><span class="sxs-lookup"><span data-stu-id="1773f-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="1773f-126">Scénarios de déconnexion du serveur</span><span class="sxs-lookup"><span data-stu-id="1773f-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="1773f-127">Paramètres de délai d’expiration et de conservation</span><span class="sxs-lookup"><span data-stu-id="1773f-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="1773f-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="1773f-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="1773f-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1773f-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="1773f-130">Mission</span><span class="sxs-lookup"><span data-stu-id="1773f-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="1773f-131">Comment modifier le délai d’attente et les paramètres KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1773f-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="1773f-132">Comment avertir l’utilisateur des déconnexions</span><span class="sxs-lookup"><span data-stu-id="1773f-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="1773f-133">Comment se reconnecter continuellement</span><span class="sxs-lookup"><span data-stu-id="1773f-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="1773f-134">Comment déconnecter un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="1773f-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="1773f-135">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="1773f-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="1773f-136">Les liens vers les rubriques de référence sur les API concernent la version .NET 4,5 de l’API.</span><span class="sxs-lookup"><span data-stu-id="1773f-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="1773f-137">Si vous utilisez .NET 4, consultez [la version .net 4 des rubriques de l’API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="1773f-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="1773f-138">Scénarios et terminologie de la durée de vie de la connexion</span><span class="sxs-lookup"><span data-stu-id="1773f-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="1773f-139">Le gestionnaire d’événements `OnReconnected` dans un concentrateur Signalr peut s’exécuter directement après `OnConnected` mais pas après `OnDisconnected` pour un client donné.</span><span class="sxs-lookup"><span data-stu-id="1773f-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="1773f-140">La raison pour laquelle vous pouvez avoir une reconnexion sans déconnexion est qu’il existe plusieurs façons d’utiliser le mot « Connection » dans Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="1773f-141">Connexions signalr, connexions de transport et connexions physiques</span><span class="sxs-lookup"><span data-stu-id="1773f-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="1773f-142">Cet article fait la distinction entre les *connexions signalr*, les *connexions de transport*et les *connexions physiques*:</span><span class="sxs-lookup"><span data-stu-id="1773f-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="1773f-143">La **connexion signalr** fait référence à une relation logique entre un client et une URL de serveur, gérée par l’API signalr et identifiée de façon unique par un ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="1773f-144">Les données relatives à cette relation sont conservées par Signalr et utilisées pour établir une connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="1773f-145">La relation se termine et Signalr supprime les données lorsque le client appelle la méthode `Stop` ou lorsqu’une limite de délai d’attente est atteinte alors que Signalr tente de rétablir une connexion de transport perdue.</span><span class="sxs-lookup"><span data-stu-id="1773f-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="1773f-146">La **connexion de transport** fait référence à une relation logique entre un client et un serveur, gérée par l’une des quatre API de transport : WebSockets, les événements envoyés par le serveur, la trame permanente ou l’interrogation longue.</span><span class="sxs-lookup"><span data-stu-id="1773f-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="1773f-147">Signalr utilise l’API de transport pour créer une connexion de transport, et l’API de transport dépend de l’existence d’une connexion réseau physique pour créer la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="1773f-148">La connexion de transport se termine lorsque Signalr le termine ou lorsque l’API de transport détecte que la connexion physique est interrompue.</span><span class="sxs-lookup"><span data-stu-id="1773f-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="1773f-149">La **connexion physique** fait référence aux liens réseau physiques (câbles, signaux sans fil, routeurs, etc.) qui facilitent la communication entre un ordinateur client et un ordinateur serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="1773f-150">La connexion physique doit être présente afin d’établir une connexion de transport, et une connexion de transport doit être établie afin d’établir une connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="1773f-151">Toutefois, l’interruption de la connexion physique ne met pas toujours immédiatement fin à la connexion de transport ou à la connexion Signalr, comme expliqué plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="1773f-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="1773f-152">Dans le diagramme suivant, la connexion Signalr est représentée par l’API hubs et la couche Signalr de l’API PersistentConnection, la connexion de transport est représentée par la couche de transport et la connexion physique est représentée par les lignes entre le serveur et les clients.</span><span class="sxs-lookup"><span data-stu-id="1773f-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagramme d’architecture signalr](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="1773f-154">Lorsque vous appelez la méthode `Start` dans un client Signalr, vous fournissez au code client Signalr toutes les informations dont il a besoin pour établir une connexion physique à un serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="1773f-155">Le code client signalr utilise ces informations pour effectuer une requête HTTP et établir une connexion physique qui utilise l’une des quatre méthodes de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="1773f-156">En cas d’échec de la connexion de transport ou de défaillance du serveur, la connexion Signalr ne disparaît pas immédiatement, car le client dispose toujours des informations nécessaires pour rétablir automatiquement une nouvelle connexion de transport à la même URL Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="1773f-157">Dans ce scénario, aucune intervention de l’application utilisateur n’est impliquée, et lorsque le code client Signalr établit une nouvelle connexion de transport, il ne démarre pas une nouvelle connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="1773f-158">La continuité de la connexion Signalr est reflétée dans le fait que l’ID de connexion, qui est créé lorsque vous appelez la méthode `Start`, ne change pas.</span><span class="sxs-lookup"><span data-stu-id="1773f-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="1773f-159">Le gestionnaire d’événements `OnReconnected` sur le Hub s’exécute lorsqu’une connexion de transport est automatiquement rétablie après avoir été perdue.</span><span class="sxs-lookup"><span data-stu-id="1773f-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="1773f-160">Le gestionnaire d’événements `OnDisconnected` s’exécute à la fin d’une connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="1773f-161">Une connexion Signalr peut se terminer de l’une des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="1773f-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="1773f-162">Si le client appelle la méthode `Stop`, un message d’arrêt est envoyé au serveur et le client et le serveur terminent la connexion Signalr immédiatement.</span><span class="sxs-lookup"><span data-stu-id="1773f-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="1773f-163">Après la perte de connectivité entre le client et le serveur, le client tente de se reconnecter et le serveur attend que le client se reconnecte.</span><span class="sxs-lookup"><span data-stu-id="1773f-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="1773f-164">Si les tentatives de reconnexion échouent et que le délai d’attente de déconnexion se termine, le client et le serveur terminent la connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="1773f-165">Le client cesse de tenter de se reconnecter, et le serveur supprime sa représentation de la connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="1773f-166">Si le client cesse de s’exécuter sans avoir la possibilité d’appeler la méthode `Stop`, le serveur attend que le client se reconnecte, puis met fin à la connexion Signalr après le délai de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="1773f-167">Si le serveur arrête de fonctionner, le client tente de se reconnecter (recrée la connexion de transport), puis met fin à la connexion Signalr après le délai d’attente de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="1773f-168">En l’absence de problèmes de connexion, si l’application utilisateur met fin à la connexion Signalr en appelant la méthode `Stop`, la connexion Signalr et la connexion de transport commencent et se terminent à la même heure.</span><span class="sxs-lookup"><span data-stu-id="1773f-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="1773f-169">Les sections suivantes décrivent plus en détail les autres scénarios.</span><span class="sxs-lookup"><span data-stu-id="1773f-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="1773f-170">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="1773f-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="1773f-171">Les connexions physiques peuvent être lentes ou il peut y avoir des interruptions de connectivité.</span><span class="sxs-lookup"><span data-stu-id="1773f-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="1773f-172">En fonction de facteurs tels que la longueur de l’interruption, la connexion de transport peut être abandonnée.</span><span class="sxs-lookup"><span data-stu-id="1773f-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="1773f-173">Signalr essaie ensuite de rétablir la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="1773f-174">Parfois, l’API de connexion de transport détecte l’interruption et abandonne la connexion de transport, et signale immédiatement que la connexion est perdue.</span><span class="sxs-lookup"><span data-stu-id="1773f-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="1773f-175">Dans d’autres scénarios, ni l’API de connexion de transport, ni signaler ne prend immédiatement en compte la perte de connectivité.</span><span class="sxs-lookup"><span data-stu-id="1773f-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="1773f-176">Pour tous les transports à l’exception de l’interrogation longue, le client Signalr utilise une fonction appelée *KeepAlive* pour vérifier la perte de connectivité que l’API de transport ne peut pas détecter.</span><span class="sxs-lookup"><span data-stu-id="1773f-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="1773f-177">Pour plus d’informations sur les connexions à interrogation longue, consultez [expiration et paramètres KeepAlive](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="1773f-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="1773f-178">Lorsqu’une connexion est inactive, le serveur envoie régulièrement un paquet KeepAlive au client.</span><span class="sxs-lookup"><span data-stu-id="1773f-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="1773f-179">À compter de la date d’écriture de cet article, la fréquence par défaut est toutes les 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="1773f-180">En écoutant ces paquets, les clients peuvent déterminer s’il existe un problème de connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="1773f-181">Si un paquet KeepAlive n’est pas reçu quand cela est attendu, après un bref moment, le client suppose qu’il y a des problèmes de connexion tels que la lenteur ou les interruptions.</span><span class="sxs-lookup"><span data-stu-id="1773f-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="1773f-182">Si le KeepAlive n’est toujours pas reçu après une période plus longue, le client suppose que la connexion a été supprimée et commence à tenter de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="1773f-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="1773f-183">Le diagramme suivant illustre les événements client et serveur qui sont déclenchés dans un scénario classique lorsqu’il y a des problèmes avec la connexion physique qui ne sont pas immédiatement reconnus par l’API de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="1773f-184">Le diagramme s’applique aux circonstances suivantes :</span><span class="sxs-lookup"><span data-stu-id="1773f-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="1773f-185">Le transport est de la trame WebSocket, de l’image permanente ou des événements envoyés par le serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="1773f-186">Il y a différentes périodes d’interruption dans la connexion réseau physique.</span><span class="sxs-lookup"><span data-stu-id="1773f-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="1773f-187">L’API de transport ne prend pas en charge les interruptions, donc Signalr s’appuie sur la fonctionnalité KeepAlive pour les détecter.</span><span class="sxs-lookup"><span data-stu-id="1773f-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Déconnexions de transport](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="1773f-189">Si le client passe en mode de reconnexion mais ne peut pas établir de connexion de transport dans le délai imparti, le serveur met fin à la connexion Signalr.</span><span class="sxs-lookup"><span data-stu-id="1773f-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="1773f-190">Lorsque cela se produit, le serveur exécute la méthode de `OnDisconnected` du Hub et met en file d’attente un message de déconnexion à envoyer au client au cas où le client se connecte pour se connecter ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="1773f-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="1773f-191">Si le client se reconnecte, il reçoit la commande Disconnect et appelle la méthode `Stop`.</span><span class="sxs-lookup"><span data-stu-id="1773f-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="1773f-192">Dans ce scénario, `OnReconnected` n’est pas exécutée lorsque le client se reconnecte, et `OnDisconnected` n’est pas exécutée lorsque le client appelle `Stop`.</span><span class="sxs-lookup"><span data-stu-id="1773f-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="1773f-193">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="1773f-193">The following diagram illustrates this scenario.</span></span>

![Interruptions de transport-délai d’expiration du serveur](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="1773f-195">Les événements de durée de vie de connexion Signalr qui peuvent être déclenchés sur le client sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="1773f-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="1773f-196">événement client `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="1773f-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="1773f-197">Déclenché lorsqu’une proportion prédéfinie du délai d’attente de conservation de la durée de conservation a été dépassée depuis la réception du dernier message ou du ping KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="1773f-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1773f-198">La période d’avertissement du délai d’attente de conservation par défaut est 2/3 du délai d’expiration de conservation.</span><span class="sxs-lookup"><span data-stu-id="1773f-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="1773f-199">Le délai d’expiration de conservation est de 20 secondes. l’avertissement se produit donc à environ 13 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="1773f-200">Par défaut, le serveur envoie des pings KeepAlive toutes les 10 secondes, et le client vérifie les pings KeepAlive environ toutes les 2 secondes (un tiers de la différence entre la valeur du délai d’expiration KeepAlive et la valeur de l’avertissement de délai d’attente KeepAlive).</span><span class="sxs-lookup"><span data-stu-id="1773f-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="1773f-201">Si l’API de transport est informée d’une déconnexion, Signalr peut être informé de la déconnexion avant que la période d’avertissement du délai d’attente de conservation de connexion ne soit dépassée.</span><span class="sxs-lookup"><span data-stu-id="1773f-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="1773f-202">Dans ce cas, l’événement `ConnectionSlow` n’est pas déclenché, et Signalr accède directement à l’événement `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="1773f-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="1773f-203">événement client `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="1773f-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="1773f-204">Déclenché lorsque (a) l’API de transport détecte que la connexion est perdue, ou (b) le délai d’attente de la conservation des connexions persistantes est dépassé depuis la réception du dernier message ou du ping KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="1773f-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1773f-205">Le code client Signalr commence la tentative de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="1773f-206">Vous pouvez gérer cet événement si vous souhaitez que votre application prenne des mesures lorsqu’une connexion de transport est perdue.</span><span class="sxs-lookup"><span data-stu-id="1773f-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="1773f-207">Le délai d’expiration de la conservation par défaut est actuellement de 20 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="1773f-208">Si votre code client tente d’appeler une méthode de concentrateur alors que Signalr est en mode de reconnexion, Signalr essaiera d’envoyer la commande.</span><span class="sxs-lookup"><span data-stu-id="1773f-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="1773f-209">La plupart du temps, ces tentatives échouent, mais dans certains cas, elles peuvent réussir.</span><span class="sxs-lookup"><span data-stu-id="1773f-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="1773f-210">Pour les transports d’événements envoyés par le serveur, indéfiniment et de longue durée, Signalr utilise deux canaux de communication : l’un utilisé par le client pour envoyer des messages et l’autre pour recevoir des messages.</span><span class="sxs-lookup"><span data-stu-id="1773f-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="1773f-211">Le canal utilisé pour la réception est le canal ouvert de manière permanente et c’est celui qui est fermé lorsque la connexion physique est interrompue.</span><span class="sxs-lookup"><span data-stu-id="1773f-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="1773f-212">Le canal utilisé pour l’envoi reste disponible. par conséquent, si la connectivité physique est restaurée, un appel de méthode du client au serveur peut être réussi avant que le canal de réception ne soit rétabli.</span><span class="sxs-lookup"><span data-stu-id="1773f-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="1773f-213">La valeur de retour n’est pas reçue tant que signaler n’a pas rouvert le canal utilisé pour la réception.</span><span class="sxs-lookup"><span data-stu-id="1773f-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="1773f-214">événement client `Reconnected`.</span><span class="sxs-lookup"><span data-stu-id="1773f-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="1773f-215">Déclenché lorsque la connexion de transport est rétablie.</span><span class="sxs-lookup"><span data-stu-id="1773f-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="1773f-216">Le gestionnaire d’événements `OnReconnected` dans le Hub s’exécute.</span><span class="sxs-lookup"><span data-stu-id="1773f-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="1773f-217">`Closed` événement client (`disconnected` dans JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1773f-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="1773f-218">Déclenché lorsque le délai d’attente de déconnexion expire alors que le code du client Signalr tente de se reconnecter après avoir perdu la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="1773f-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="1773f-219">Le délai d’attente de déconnexion par défaut est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="1773f-220">(Cet événement est également déclenché lorsque la connexion se termine, car la méthode `Stop` est appelée.)</span><span class="sxs-lookup"><span data-stu-id="1773f-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="1773f-221">Les interruptions de connexion de transport qui ne sont pas détectées par l’API de transport et qui ne retardent pas la réception des pings KeepAlive à partir du serveur pendant plus longtemps que la période d’avertissement du délai d’attente KeepAlive peuvent ne pas entraîner le déclenchement d’événements de durée de vie de connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="1773f-222">Certains environnements réseau ferment délibérément des connexions inactives, et une autre fonction des paquets KeepAlive est de vous aider à éviter cela en laissant ces réseaux savoir qu’une connexion Signalr est en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="1773f-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="1773f-223">Dans les cas extrêmes, la fréquence par défaut des pings KeepAlive peut ne pas suffire pour empêcher les connexions fermées.</span><span class="sxs-lookup"><span data-stu-id="1773f-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="1773f-224">Dans ce cas, vous pouvez configurer des pings KeepAlive à envoyer plus souvent.</span><span class="sxs-lookup"><span data-stu-id="1773f-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="1773f-225">Pour plus d’informations, consultez la section [paramètres de délai d’attente et conservation](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="1773f-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="1773f-226">**Important**: la séquence d’événements décrite ici n’est pas garantie.</span><span class="sxs-lookup"><span data-stu-id="1773f-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="1773f-227">Signalr effectue chaque tentative d’augmentation des événements de durée de vie de la connexion de manière prévisible en fonction de ce schéma, mais il existe de nombreuses variantes d’événements réseau et de nombreuses façons dont les infrastructures de communication sous-jacentes telles que les API de transport les gèrent.</span><span class="sxs-lookup"><span data-stu-id="1773f-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="1773f-228">Par exemple, l’événement `Reconnected` peut ne pas être déclenché lorsque le client se reconnecte, ou le gestionnaire de `OnConnected` sur le serveur peut s’exécuter lorsque la tentative d’établissement d’une connexion échoue.</span><span class="sxs-lookup"><span data-stu-id="1773f-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="1773f-229">Cette rubrique décrit uniquement les effets qui seraient normalement produits par certaines circonstances typiques.</span><span class="sxs-lookup"><span data-stu-id="1773f-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="1773f-230">Scénarios de déconnexion du client</span><span class="sxs-lookup"><span data-stu-id="1773f-230">Client disconnection scenarios</span></span>

<span data-ttu-id="1773f-231">Dans un navigateur client, le code client Signalr qui gère une connexion Signalr s’exécute dans le contexte JavaScript d’une page Web.</span><span class="sxs-lookup"><span data-stu-id="1773f-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="1773f-232">C’est pourquoi la connexion Signalr doit se terminer lorsque vous naviguez d’une page à une autre, et c’est pourquoi vous avez plusieurs connexions avec plusieurs ID de connexion si vous vous connectez à partir de plusieurs fenêtres ou onglets du navigateur.</span><span class="sxs-lookup"><span data-stu-id="1773f-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="1773f-233">Quand l’utilisateur ferme une fenêtre ou un onglet de navigateur, ou accède à une nouvelle page ou actualise la page, la connexion Signalr se termine immédiatement, car le code client Signalr gère cet événement de navigateur pour vous et appelle la méthode `Stop`.</span><span class="sxs-lookup"><span data-stu-id="1773f-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="1773f-234">Dans ces scénarios, ou sur n’importe quelle plateforme cliente lorsque votre application appelle la méthode `Stop`, le gestionnaire d’événements `OnDisconnected` s’exécute immédiatement sur le serveur et le client déclenche l’événement `Closed` (l’événement est nommé `disconnected` dans JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1773f-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="1773f-235">Si une application cliente ou l’ordinateur sur lequel elle s’exécute s’arrête ou passe en mode veille (par exemple, lorsque l’utilisateur ferme l’ordinateur portable), le serveur n’est pas informé de ce qui s’est passé.</span><span class="sxs-lookup"><span data-stu-id="1773f-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="1773f-236">En ce qui concerne le serveur, la perte du client peut être due à une interruption de la connectivité et le client peut tenter de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="1773f-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="1773f-237">Par conséquent, dans ces scénarios, le serveur attend de permettre au client de se reconnecter, et `OnDisconnected` ne s’exécute pas tant que le délai d’attente de déconnexion n’a pas expiré (environ 30 secondes par défaut).</span><span class="sxs-lookup"><span data-stu-id="1773f-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="1773f-238">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="1773f-238">The following diagram illustrates this scenario.</span></span>

![Défaillance de l’ordinateur client](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="1773f-240">Scénarios de déconnexion du serveur</span><span class="sxs-lookup"><span data-stu-id="1773f-240">Server disconnection scenarios</span></span>

<span data-ttu-id="1773f-241">Lorsqu’un serveur est mis hors connexion, il redémarre, échoue, les recyclages de domaine d’application, etc., le résultat peut être similaire à une connexion perdue, ou l’API de transport et Signalr peut savoir immédiatement que le serveur a disparu, et Signalr peut commencer à tenter de se reconnecter sans déclencher l’événement `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="1773f-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="1773f-242">Si le client passe en mode de reconnexion, et si le serveur récupère ou redémarre ou si un nouveau serveur est mis en ligne avant l’expiration du délai d’attente de déconnexion, le client se reconnecte au serveur restauré ou nouveau.</span><span class="sxs-lookup"><span data-stu-id="1773f-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="1773f-243">Dans ce cas, la connexion Signalr continue sur le client et l’événement `Reconnected` est déclenché.</span><span class="sxs-lookup"><span data-stu-id="1773f-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="1773f-244">Sur le premier serveur, `OnDisconnected` n’est jamais exécutée, et sur le nouveau serveur, `OnReconnected` est exécutée même si `OnConnected` n’a jamais été exécutée pour ce client sur ce serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="1773f-245">(L’effet est le même si le client se reconnecte au même serveur après un redémarrage ou un recyclage de domaine d’application, car lorsque le serveur redémarre, il n’a pas de mémoire pour l’activité de connexion précédente.) Le diagramme suivant part du principe que l’API de transport est informée de la connexion perdue immédiatement, de sorte que l’événement `ConnectionSlow` n’est pas déclenché.</span><span class="sxs-lookup"><span data-stu-id="1773f-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Défaillance du serveur et reconnexion](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="1773f-247">Si un serveur n’est pas disponible dans le délai de déconnexion, la connexion Signalr se termine.</span><span class="sxs-lookup"><span data-stu-id="1773f-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="1773f-248">Dans ce scénario, l’événement `Closed` (`disconnected` dans les clients JavaScript) est déclenché sur le client, mais `OnDisconnected` n’est jamais appelé sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="1773f-249">Le diagramme suivant suppose que l’API de transport ne prend pas en charge la connexion perdue. elle est donc détectée par la fonctionnalité KeepAlive Signalr et l’événement `ConnectionSlow` est déclenché.</span><span class="sxs-lookup"><span data-stu-id="1773f-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Échec et délai d’expiration du serveur](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="1773f-251">Paramètres de délai d’expiration et de conservation</span><span class="sxs-lookup"><span data-stu-id="1773f-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="1773f-252">Les valeurs par défaut `ConnectionTimeout`, `DisconnectTimeout`et `KeepAlive` sont appropriées pour la plupart des scénarios, mais elles peuvent être modifiées si votre environnement a des besoins spéciaux.</span><span class="sxs-lookup"><span data-stu-id="1773f-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="1773f-253">Par exemple, si votre environnement réseau ferme des connexions inactives pendant 5 secondes, vous devrez peut-être réduire la valeur KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="1773f-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="1773f-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="1773f-254">ConnectionTimeout</span></span>

<span data-ttu-id="1773f-255">Ce paramètre représente la durée pendant laquelle une connexion de transport doit rester ouverte et en attente d’une réponse avant sa fermeture et l’ouverture d’une nouvelle connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="1773f-256">La valeur par défaut est 110 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="1773f-257">Ce paramètre s’applique uniquement lorsque la fonctionnalité KeepAlive est désactivée, ce qui s’applique normalement uniquement au transport d’interrogation longue.</span><span class="sxs-lookup"><span data-stu-id="1773f-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="1773f-258">Le diagramme suivant illustre l’effet de ce paramètre sur une connexion de transport d’interrogation longue.</span><span class="sxs-lookup"><span data-stu-id="1773f-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Connexion de transport d’interrogation longue](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="1773f-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1773f-260">DisconnectTimeout</span></span>

<span data-ttu-id="1773f-261">Ce paramètre représente la durée d’attente après la perte d’une connexion de transport avant le déclenchement de l’événement `Disconnected`.</span><span class="sxs-lookup"><span data-stu-id="1773f-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="1773f-262">La valeur par défaut est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-262">The default value is 30 seconds.</span></span> <span data-ttu-id="1773f-263">Lorsque vous définissez `DisconnectTimeout`, `KeepAlive` est automatiquement défini sur 1/3 de la valeur de `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="1773f-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="1773f-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1773f-264">KeepAlive</span></span>

<span data-ttu-id="1773f-265">Ce paramètre représente la durée d’attente avant l’envoi d’un paquet KeepAlive sur une connexion inactive.</span><span class="sxs-lookup"><span data-stu-id="1773f-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="1773f-266">La valeur par défaut est 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="1773f-266">The default value is 10 seconds.</span></span> <span data-ttu-id="1773f-267">Cette valeur ne doit pas être supérieure à 1/3 de la valeur `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="1773f-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="1773f-268">Si vous souhaitez définir à la fois `DisconnectTimeout` et `KeepAlive`, définissez `KeepAlive` après `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="1773f-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="1773f-269">Dans le cas contraire, votre `KeepAlive` paramètre sera remplacé lorsque `DisconnectTimeout` définira automatiquement `KeepAlive` sur 1/3 de la valeur du délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="1773f-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="1773f-270">Si vous souhaitez désactiver la fonctionnalité KeepAlive, affectez à `KeepAlive` la valeur null.</span><span class="sxs-lookup"><span data-stu-id="1773f-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="1773f-271">La fonctionnalité KeepAlive est automatiquement désactivée pour le transport d’interrogation longue.</span><span class="sxs-lookup"><span data-stu-id="1773f-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="1773f-272">Comment modifier le délai d’attente et les paramètres KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1773f-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="1773f-273">Pour modifier les valeurs par défaut de ces paramètres, définissez-les dans `Application_Start` dans votre fichier *global. asax* , comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="1773f-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="1773f-274">Les valeurs affichées dans l’exemple de code sont les mêmes que les valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="1773f-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="1773f-275">Comment avertir l’utilisateur des déconnexions</span><span class="sxs-lookup"><span data-stu-id="1773f-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="1773f-276">Dans certaines applications, vous souhaiterez peut-être afficher un message à l’utilisateur lorsqu’il y a des problèmes de connectivité.</span><span class="sxs-lookup"><span data-stu-id="1773f-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="1773f-277">Vous disposez de plusieurs options pour savoir quand et comment procéder.</span><span class="sxs-lookup"><span data-stu-id="1773f-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="1773f-278">Les exemples de code suivants concernent un client JavaScript qui utilise le proxy généré.</span><span class="sxs-lookup"><span data-stu-id="1773f-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="1773f-279">Gérez l’événement `connectionSlow` pour afficher un message dès que Signalr est conscient des problèmes de connexion, avant qu’il ne passe en mode de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="1773f-280">Gérez l’événement `reconnecting` pour afficher un message lorsque Signalr est conscient d’une déconnexion et passe en mode de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="1773f-281">Gérez l’événement `disconnected` pour afficher un message quand une tentative de reconnexion a expiré. Dans ce scénario, le seul moyen de rétablir une connexion avec le serveur consiste à redémarrer la connexion Signalr en appelant la méthode `Start`, qui créera un nouvel ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="1773f-282">L’exemple de code suivant utilise un indicateur pour s’assurer que vous émettez la notification uniquement après un délai de reconnexion, et non après une fin normale à la connexion Signalr provoquée par l’appel de la méthode `Stop`.</span><span class="sxs-lookup"><span data-stu-id="1773f-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="1773f-283">Comment se reconnecter continuellement</span><span class="sxs-lookup"><span data-stu-id="1773f-283">How to continuously reconnect</span></span>

<span data-ttu-id="1773f-284">Dans certaines applications, vous souhaiterez peut-être rétablir automatiquement une connexion une fois qu’elle a été perdue et que la tentative de reconnexion a expiré. Pour ce faire, vous pouvez appeler la méthode `Start` à partir de votre gestionnaire d’événements `Closed` (`disconnected` gestionnaire d’événements sur les clients JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1773f-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="1773f-285">Vous souhaiterez peut-être attendre un certain temps avant d’appeler `Start` afin d’éviter que cela soit trop fréquent lorsque le serveur ou la connexion physique ne sont pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="1773f-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="1773f-286">L’exemple de code suivant est destiné à un client JavaScript qui utilise le proxy généré.</span><span class="sxs-lookup"><span data-stu-id="1773f-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="1773f-287">Un problème potentiel à connaître dans les clients mobiles est que les tentatives de reconnexion continue lorsque le serveur ou la connexion physique n’est pas disponible peuvent entraîner un vidage de batterie inutile.</span><span class="sxs-lookup"><span data-stu-id="1773f-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="1773f-288">Comment déconnecter un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="1773f-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="1773f-289">Signalr version 2 ne dispose pas d’une API serveur intégrée pour déconnecter les clients.</span><span class="sxs-lookup"><span data-stu-id="1773f-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="1773f-290">Il existe des [plans pour l’ajout de cette fonctionnalité à l’avenir](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="1773f-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="1773f-291">Dans la version actuelle de Signalr, la façon la plus simple de déconnecter un client du serveur consiste à implémenter une méthode de déconnexion sur le client et à appeler cette méthode à partir du serveur.</span><span class="sxs-lookup"><span data-stu-id="1773f-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="1773f-292">L’exemple de code suivant montre une méthode de déconnexion pour un client JavaScript qui utilise le proxy généré.</span><span class="sxs-lookup"><span data-stu-id="1773f-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="1773f-293">Sécurité : ni cette méthode de déconnexion des clients ni l’API intégrée proposée ne concernent le scénario des clients piratés qui exécutent du code malveillant, puisque les clients peuvent se reconnecter ou que le code piraté peut supprimer la méthode `stopClient` ou changer ce qu’elle fait.</span><span class="sxs-lookup"><span data-stu-id="1773f-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="1773f-294">L’emplacement approprié pour implémenter la protection contre les dénis de service avec état n’est pas dans l’infrastructure ou la couche serveur, mais plutôt dans l’infrastructure frontale.</span><span class="sxs-lookup"><span data-stu-id="1773f-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="1773f-295">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="1773f-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="1773f-296">Signalr 2,1 ajoute une surcharge à l’événement de `OnDisconnect` serveur qui indique si le client délibérément déconnecté plutôt que le délai d’expiration. Le paramètre `StopCalled` a la valeur true si le client a explicitement fermé la connexion.</span><span class="sxs-lookup"><span data-stu-id="1773f-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="1773f-297">En JavaScript, si une erreur de serveur conduit le client à se déconnecter, les informations sur l’erreur sont transmises au client en tant que `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="1773f-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="1773f-298">**C#code serveur : paramètre `stopCalled`**</span><span class="sxs-lookup"><span data-stu-id="1773f-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="1773f-299">**Code client JavaScript : accès à `lastError` dans l’événement `disconnect`.**</span><span class="sxs-lookup"><span data-stu-id="1773f-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
