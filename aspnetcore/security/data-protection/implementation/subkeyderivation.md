---
title: Dérivation de sous-clé et chiffrement authentifié dans ASP.NET Core
author: rick-anderson
description: Découvrez les détails d’implémentation de la Protection des données ASP.NET Core dérivation de sous-clé et authentifiés de chiffrement.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/01/2019
ms.locfileid: "57047246"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="1933c-103">Dérivation de sous-clé et chiffrement authentifié dans ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="1933c-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="1933c-104">La plupart des touches dans le key ring contiendra une certaine forme d’entropie et contient des informations algorithmiques indiquant « le chiffrement en mode CBC + validation de HMAC » ou « chiffrement de GCM + validation ».</span><span class="sxs-lookup"><span data-stu-id="1933c-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="1933c-105">Dans ce cas, nous faisons référence à l’entropie incorporé en tant que le support de gestion (ou KM) pour cette clé, et nous effectuons une fonction de dérivation de clé pour dériver les clés qui seront utilisés pour les opérations de chiffrement réelles.</span><span class="sxs-lookup"><span data-stu-id="1933c-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="1933c-106">Les clés sont abstraites, et une implémentation personnalisée ne peut-être pas se comporter comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="1933c-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="1933c-107">Si la clé fournit sa propre implémentation de `IAuthenticatedEncryptor` au lieu d’utiliser un de nos fabriques intégrées, le mécanisme décrit dans cette section ne s’applique plus.</span><span class="sxs-lookup"><span data-stu-id="1933c-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="1933c-108">Données authentifiées supplémentaires et dérivation de sous-clé</span><span class="sxs-lookup"><span data-stu-id="1933c-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="1933c-109">Le `IAuthenticatedEncryptor` interface sert d’interface de base pour toutes les opérations de chiffrement authentifié.</span><span class="sxs-lookup"><span data-stu-id="1933c-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="1933c-110">Son `Encrypt` méthode accepte deux mémoires tampons : texte en clair et additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="1933c-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="1933c-111">Le flux de contenu de texte en clair inchangé de l’appel à `IDataProtector.Protect`, mais AAD est généré par le système et se compose de trois composants :</span><span class="sxs-lookup"><span data-stu-id="1933c-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="1933c-112">L’en-tête magique de 32 bits 09 F0 C9 F0 qui identifie cette version du système de protection des données.</span><span class="sxs-lookup"><span data-stu-id="1933c-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="1933c-113">L’id de clé de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="1933c-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="1933c-114">Une chaîne de longueur variable formée à partir de la chaîne d’usage qui a créé le `IDataProtector` qui effectue cette opération.</span><span class="sxs-lookup"><span data-stu-id="1933c-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="1933c-115">Car AAD est unique pour le tuple de tous les trois composants, nous pouvons l’utiliser pour dériver les nouvelles clés à partir du Gestionnaire de clés au lieu d’utiliser le Gestionnaire de clés lui-même dans tous les de nos opérations de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="1933c-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="1933c-116">Pour chaque appel à `IAuthenticatedEncryptor.Encrypt`, le processus de dérivation de clé suivant a lieu :</span><span class="sxs-lookup"><span data-stu-id="1933c-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="1933c-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="1933c-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="1933c-118">Ici, nous appelons NIST SP800-108 KDF en Mode de compteur (consultez [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), s. 5.1) avec les paramètres suivants :</span><span class="sxs-lookup"><span data-stu-id="1933c-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="1933c-119">Clé de dérivation de clé (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="1933c-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="1933c-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="1933c-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="1933c-121">label = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="1933c-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="1933c-122">context = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="1933c-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="1933c-123">L’en-tête de contexte de longueur variable, constitue essentiellement une empreinte numérique des algorithmes pour lequel nous allons dérivation K_E et K_H.</span><span class="sxs-lookup"><span data-stu-id="1933c-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="1933c-124">Le modificateur de clé est une chaîne de 128 bits générée de manière aléatoire pour chaque appel à `Encrypt` et permet de garantir avec surcharger la probabilité que KE et KH sont uniques pour cette opération de chiffrement d’authentification spécifique, même si toute autre entrée au KDF est constante.</span><span class="sxs-lookup"><span data-stu-id="1933c-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="1933c-125">Pour le chiffrement en mode CBC + des opérations de validation HMAC, | K_E | est la longueur de la clé de chiffrement par bloc symétriques, et | K_H | est la taille de la synthèse de la routine HMAC.</span><span class="sxs-lookup"><span data-stu-id="1933c-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="1933c-126">Pour le chiffrement de GCM + des opérations de validation, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="1933c-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="1933c-127">Le chiffrement en mode CBC + validation de HMAC</span><span class="sxs-lookup"><span data-stu-id="1933c-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="1933c-128">Une fois K_E est généré par le biais du mécanisme ci-dessus, nous générer un vecteur d’initialisation aléatoire et exécuter l’algorithme de chiffrement symétrique pour chiffrer le texte en clair.</span><span class="sxs-lookup"><span data-stu-id="1933c-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="1933c-129">Le vecteur d’initialisation et le texte chiffré sont ensuite exécutées via la routine HMAC initialisée avec la clé K_H pour produire le Mac.</span><span class="sxs-lookup"><span data-stu-id="1933c-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="1933c-130">Ce processus et la valeur de retour est représenté sous forme graphique ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="1933c-130">This process and the return value is represented graphically below.</span></span>

![Retour et les processus en mode CBC](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="1933c-132">*sortie : = keyModifier || vecteur d’initialisation || E_cbc (données K_E, iv) || HMAC (K_H, iv || E_cbc (données K_E, iv,))*</span><span class="sxs-lookup"><span data-stu-id="1933c-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="1933c-133">Le `IDataProtector.Protect` implémentation sera [ajouter l’en-tête magique et un id de clé](xref:security/data-protection/implementation/authenticated-encryption-details) à sortie avant de le renvoyer à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="1933c-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="1933c-134">Étant donné que l’en-tête magique et id de clé sont implicitement dans le cadre de [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), et étant donné que le modificateur de clé est acheminé comme entrée au KDF, cela signifie que chaque octet de la charge utile de retourné finale est authentifié par l’ordinateur Mac.</span><span class="sxs-lookup"><span data-stu-id="1933c-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="1933c-135">Le chiffrement en Mode de compteur/GALOIS + validation</span><span class="sxs-lookup"><span data-stu-id="1933c-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="1933c-136">Une fois K_E est généré par le biais du mécanisme ci-dessus, nous générer une valeur à usage unique à 96 bits aléatoire et exécuter l’algorithme de chiffrement symétrique pour chiffrer le texte brut et génère la balise d’authentification de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="1933c-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Retour et les processus en mode GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="1933c-138">*sortie : = keyModifier || valeur à usage unique || E_gcm (K_E, valeur à usage unique, les données) || authTag*</span><span class="sxs-lookup"><span data-stu-id="1933c-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="1933c-139">Bien que GCM prend nativement en charge le concept d’AAD, nous sommes toujours à l’alimentation AAD uniquement le KDF d’origine, qui optent pour transmettre une chaîne vide dans GCM pour son paramètre AAD.</span><span class="sxs-lookup"><span data-stu-id="1933c-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="1933c-140">La raison à cela est double.</span><span class="sxs-lookup"><span data-stu-id="1933c-140">The reason for this is two-fold.</span></span> <span data-ttu-id="1933c-141">Tout d’abord, [pour prendre en charge d’agilité](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) nous souhaitons jamais utiliser K_M directement en tant que la clé de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="1933c-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="1933c-142">En outre, GCM impose des exigences très strictes de l’unicité sur ses entrées.</span><span class="sxs-lookup"><span data-stu-id="1933c-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="1933c-143">La probabilité que la routine de chiffrement GCM n’est jamais appelée sur deux ou plus distincts définit des données d’entrée avec le même (clé, valeur à usage unique) paire ne doit pas dépasser 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="1933c-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="1933c-144">Si nous K_E résoudre le problème, nous ne pouvons pas effectuer plus de 2 ^ 32 opérations de chiffrement avant de nous afoul exécuter of le 2 ^ limiter -32.</span><span class="sxs-lookup"><span data-stu-id="1933c-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="1933c-145">Cela peut sembler un très grand nombre d’opérations, mais un serveur web de fort trafic peut passer par 4 milliards de requêtes dans des jours simples, bien au sein de la durée de vie normale pour ces clés.</span><span class="sxs-lookup"><span data-stu-id="1933c-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="1933c-146">En garantissant la conformité de 2 ^ limite de la probabilité de-32, que nous continuons d’utiliser un modificateur de clé de 128 bits et les 96 bits valeur à usage unique, qui étend radicalement le nombre d’opérations utilisable pour n’importe quel K_M donné.</span><span class="sxs-lookup"><span data-stu-id="1933c-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="1933c-147">Par souci de simplicité de conception, nous partageons le chemin d’accès du code KDF entre les opérations CBC et GCM, et AAD est déjà prises en compte dans le KDF il est inutile de transférer à la routine GCM.</span><span class="sxs-lookup"><span data-stu-id="1933c-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
